diff --git a/Makefile b/Makefile
index b971308..1f68a81 100644
--- a/Makefile
+++ b/Makefile
@@ -157,6 +157,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_find\
 
 
 ifeq ($(LAB),syscall)
@@ -242,15 +245,8 @@ qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
 
-GDBARGS = 
-GDBARGS += -ex 'set architecture riscv:rv64'
-GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
-GDBARGS += -ex 'symbol-file kernel/kernel'
-GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
-
-
 gdb: 
-	$(GDB) $(GDBARGS)
+	$(GDB)
 
 ##
 ##  FOR testing lab grading script
diff --git a/commands.gdb b/commands.gdb
new file mode 100644
index 0000000..f007646
--- /dev/null
+++ b/commands.gdb
@@ -0,0 +1,6 @@
+b trap.c 55
+c
+p cpus[$tp]->proc->name
+next
+p cpus[$tp]->proc->name
+da
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..8cefbe2
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,78 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+char *Extraname(char *path) { // 在完整路径中提取文件名
+    // 找到最后一个左斜线 '/'
+    char *p;
+    for (p = path + strlen( path ); p >= path && *p != '/'; p --) ;// 从路径末尾开始找
+    p ++;
+
+    if (strlen( p ) >= DIRSIZ)
+        return p;
+
+    static char buf[DIRSIZ + 1];
+    memmove(buf, p, strlen( p ));
+    buf[strlen( p )] = '\0';
+    return buf;
+}
+
+void Comparename(char *path,char *target) {
+    if (! strcmp(Extraname(path), target))
+        printf("%s\n", path);
+}
+void find(char *path,char *name) {
+    int fd; // 文件描述符
+
+    if ((fd = open(path, 0)) < 0) {
+        fprintf(2, "find: cannot open %s\n", path);
+        return ;
+    }
+
+    struct stat st; // 文件状态结构体
+    if (fstat(fd, &st) < 0) {
+        fprintf(2, "find: cannot stat %s\n", path);
+        return ;
+    }
+
+    char buf[512], *p;
+    struct dirent de; // 目录项结构体
+    switch ( st.type ) {
+        case T_FILE: { // 当前路径是文件
+            break;
+        }
+        case T_DIR: {
+            if (strlen( path ) + 1 + DIRSIZ + 1 > sizeof( buf )) { // 路径 + '/' + 最大文件名 + '\0'
+                printf("find: path too long to print");
+                break;
+            }
+            strcpy(buf, path);
+            p = buf + strlen( buf );
+            *p ++ = '/';
+
+            // 遍历目录
+            while (read(fd, &de, sizeof( de )) == sizeof( de )) {
+                // 跳过无效目录和 '.' ".."
+                if (de.inum == 0 || strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0)
+                    continue;
+                memmove(p, de.name, strlen( de.name )); // 拼接完整路径
+                p[strlen( de.name )] = '\0';
+
+                Comparename(buf, name);
+                find(buf, name);
+            }
+            break;
+        }
+    }
+    close( fd );
+}
+
+int main(int argc,char *argv[]) {
+    if (argc < 3) {
+        printf("find implements with format <find path filename>\n");
+        exit( -1 );
+    }
+    find(argv[1], argv[2]); // file name
+    exit( 0 );
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..308136c
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,41 @@
+#include "kernel/types.h"
+#include "user.h"
+#include "stddef.h"
+
+int main(int argc,char* argv[]) {
+   if (argc != 1) {
+        printf("pingpong needs only one augment");
+        exit( -1 );
+   }
+   int p[2]; // p[0] for read; p[1] for write
+   char buf[5];
+   pipe( p );
+   int pid;
+
+   int Res = fork();
+   if (Res == 0) { // 子进程
+     read(p[0], buf, sizeof( buf ));
+     close( p[0] );
+
+     pid = getpid();
+     printf("%d: received ping from pid %s\n", pid, buf);
+
+     itoa(pid, buf);
+     write(p[1], buf, sizeof( buf ));
+     close( p[1] );
+   }
+   else { // 父进程
+     pid = getpid();
+     itoa(pid, buf);
+
+     write(p[1], buf, sizeof( buf ));
+     close( p[1] );
+
+     wait( 0 ); // 用一根管子需要等待子进程结束，两根管子则独立
+     read(p[0], buf, sizeof( buf ));
+     close( p[0] );
+
+     printf("%d: received pong from pid %s\n", pid, buf);
+   }
+   exit( 0 );
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..1c95e87
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc,char *argv[]) {
+    if (argc != 2) {
+        printf("Sleep needs one argument!\n");
+        exit( -1 );
+    }
+    int ticks = atoi( argv[1] );
+    sleep( ticks );
+    printf("(nothing happens for a little while)\n");
+    exit( 0 );
+}
\ No newline at end of file
